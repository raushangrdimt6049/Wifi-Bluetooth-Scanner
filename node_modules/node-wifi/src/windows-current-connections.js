const execFile = require('child_process').execFile;
const env = require('./env');
const networkUtils = require('./utils/network-utils.js');

function parseShowInterfaces(stdout) {
  const output = stdout.toString('utf8');
  const connections = [];
  const seenBssids = new Set();

  // Each interface output is separated by a double newline.
  const interfaces = output.split(/\r?\n\r?\n/);

  for (const iface of interfaces) {
    if (iface.trim() === '') {
      continue;
    }
    const lines = iface.split(/\r?\n/);
    const details = {};

    for (const line of lines) {
      const match = line.match(/\s*(.*?)\s*:\s*(.*)/);
      if (match && match[1] && match[2]) {
        const key = match[1].trim();
        const value = match[2].trim();
        if (key && value) {
          details[key] = value;
        }
      }
    }

    if (details.State === 'connected' && details.SSID && details.BSSID) {
      if (seenBssids.has(details.BSSID)) {
        continue;
      }
      seenBssids.add(details.BSSID);

      const quality = parseInt(details.Signal, 10) || 0;

      const channel = parseInt(details.Channel, 10) || 0;
      const frequencyVal = channel
        ? networkUtils.frequencyFromChannel(channel)
        : 0;
      const frequency = frequencyVal ? parseInt(frequencyVal, 10) : 0;

      connections.push({
        iface: details.Name,
        ssid: details.SSID,
        profile: details.Profile || '',
        bssid: details.BSSID,
        mac: details.BSSID, // for retrocompatibility
        mode: details['Network type'] || '',
        channel: channel,
        frequency: frequency,
        quality: quality,
        signal_level: networkUtils.dBFromQuality(quality),
        security: details.Authentication || '',
        security_flags: details.Cipher || ''
      });
    }
  }

  return connections;
}

function getCurrentConnection(config, callback) {
  const params = ['wlan', 'show', 'interfaces'];
  execFile('netsh', params, { env }, (err, stdout, stderr) => {
    if (err) {
      const error = new Error(
        `Getting current connections failed: ${err.message || stderr || stdout}`
      );
      Object.assign(error, err);
      if (stderr.includes('not running')) {
        error.message +=
          '\n\nHint: The Wireless AutoConfig Service (wlansvc) may not be running.\n' +
          'Try running "net start wlansvc" in an administrator command prompt.';
      } else if (stderr.match(/interface.*not found/i)) {
        error.message +=
          '\n\nHint: No wireless interface was found.\n' +
          'Please ensure your Wi-Fi adapter is enabled and not in airplane mode.';
      }
      callback && callback(error);
      return;
    }

    if (stdout.match(/no wireless interface/i)) {
      const error = new Error(
        'Getting current connections failed: No wireless interface was found.'
      );
      error.message +=
        '\n\nHint: No wireless interface was found.\n' +
        'Please ensure your Wi-Fi adapter is enabled and not in airplane mode.';
      callback && callback(error);
    } else {
      try {
        const connections = parseShowInterfaces(stdout);
        callback && callback(null, connections);
      } catch (e) {
        callback && callback(e);
      }
    }
  });
}

module.exports = config => {
  return callback => {
    if (callback) {
      getCurrentConnection(config, callback);
    } else {
      return new Promise((resolve, reject) => {
        getCurrentConnection(config, (err, connections) => {
          if (err) {
            reject(err);
          } else {
            resolve(connections);
          }
        });
      });
    }
  };
};
