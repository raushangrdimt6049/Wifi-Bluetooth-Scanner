const execFile = require('child_process').execFile;
const networkUtils = require('./utils/network-utils');
const env = require('./env');
const getCurrentConnectionsModule = require('./windows-current-connections.js');

function scanWifi(config, callback) {
  const getCurrentConnections = getCurrentConnectionsModule(config);

  getCurrentConnections((err, currentConnections) => {
    // If we can't get current connections, we'll just scan without filtering.
    const connectedSsids =
      !err && currentConnections
        ? currentConnections.map(conn => conn.ssid)
        : [];

    try {
      execFile(
        'netsh',
        ['wlan', 'show', 'networks', 'mode=Bssid'],
        { env },
        (err, stdout, stderr) => {
          if (err) {
            const error = new Error(
              `Scanning failed: ${err.message || stderr || stdout}`
            );
            Object.assign(error, err);

            if (stderr.includes('not running')) {
              error.message +=
                '\n\nHint: The Wireless AutoConfig Service (wlansvc) may not be running.\n' +
                'Try running "net start wlansvc" in an administrator command prompt.';
            } else if (
              stderr.match(/interface.*not found/i) ||
              stdout.match(/no wireless interface/i)
            ) {
              error.message +=
                '\n\nHint: No wireless interface was found.\n' +
                'Please ensure your Wi-Fi adapter is enabled and not in airplane mode.';
            }

            callback && callback(error);
            return;
          }

          const allNetworks = parse(stdout);

          const networks = allNetworks.filter(
            net => !connectedSsids.includes(net.ssid)
          );

          callback && callback(null, networks);
        }
      );
    } catch (e) {
      callback && callback(e);
    }
  });
}

function parse(stdout) {
  const networks = [];
  const lines = stdout.toString('utf8').split(/\r?\n/);

  let currentSSIDProps = null;
  let currentBSSIDProps = null;

  function pushCurrentBSSID() {
    if (currentBSSIDProps) {
      networks.push(currentBSSIDProps);
      currentBSSIDProps = null;
    }
  }

  for (const line of lines) {
    const ssidMatch = line.match(/^SSID \d+\s*:\s*(.*)/);
    if (ssidMatch) {
      pushCurrentBSSID();
      currentSSIDProps = {
        ssid: ssidMatch[1].trim()
      };
      continue;
    }

    const bssidMatch = line.match(/^\s+BSSID \d+\s*:\s*(.*)/);
    if (bssidMatch) {
      pushCurrentBSSID();
      if (currentSSIDProps) {
        currentBSSIDProps = {
          ...currentSSIDProps,
          mac: bssidMatch[1].trim(),
          bssid: bssidMatch[1].trim()
        };
      }
      continue;
    }

    if (!currentSSIDProps) {
      continue; // Skip header lines
    }

    const propMatch = line.match(/^\s+(.*?)\s*:\s*(.*)/);
    if (!propMatch) {
      continue;
    }

    const key = propMatch[1].trim();
    const value = propMatch[2].trim();

    const target = currentBSSIDProps || currentSSIDProps;

    switch (key) {
      case 'Network type':
        target.mode = value;
        break;
      case 'Authentication':
        target.security = value;
        break;
      case 'Encryption':
        target.security_flags = value;
        break;
      case 'Signal':
        if (currentBSSIDProps) {
          const quality = parseInt(value, 10) || 0;
          currentBSSIDProps.quality = quality;
          currentBSSIDProps.signal_level = networkUtils.dBFromQuality(quality);
        }
        break;
      case 'Channel':
        if (currentBSSIDProps) {
          const channel = parseInt(value, 10) || -1;
          currentBSSIDProps.channel = channel;
          currentBSSIDProps.frequency =
            channel > 0
              ? parseInt(networkUtils.frequencyFromChannel(channel), 10)
              : 0;
        }
        break;
    }
  }

  pushCurrentBSSID(); // Push the last one

  return networks;
}

module.exports = config => {
  return callback => {
    if (callback) {
      scanWifi(config, callback);
    } else {
      return new Promise((resolve, reject) => {
        scanWifi(config, (err, networks) => {
          if (err) {
            reject(err);
          } else {
            resolve(networks);
          }
        });
      });
    }
  };
};
